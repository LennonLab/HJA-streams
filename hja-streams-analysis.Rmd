---
title: Bacterial community assembly differs between benthic and planktonic stream
  habitats
author: "Nathan I. Wisnoski and Jay T. Lennon"
date: "2019-01-04"
output: pdf_document
---

# Initial setup 
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  fig.align = "center", 
  fig.width = 7
)

# Check for and install required packages
package.list <- c('vegan', 'png', 'grid', 'simba',
                  'vegetarian', 'pander', 'fossil',
                  'cluster', 'adespatial', 'spdep', 
                  'stringr', 'picante', 'phytools', 'GUniFrac', 
                  'data.table', 'tidyverse')

for (package in package.list) {
  if (!require(package, character.only=T, quietly=T)) {
    install.packages(package)
    library(package, character.only=T)
  }
}

# load external functions
source("analysis/mothur_tools.R")
source("analysis/hja_functions.R")
```

First, we load the data. This includes the site-by-species matrix (generated in Mothur, v. 1.41.1), the RDP taxonomy, the environmental data, and the phylogenetic tree (generated with FastTreeMP).
```{r load}
## Import Shared, Design, and Environment Files

# Define Inputs
# Design = general design file for experiment
# shared = OTU table from mothur with sequence similarity clustering
# Taxonomy = Taxonomic information for each OTU

# Import Design
design.total <- read.delim("data/design.txt", header=T, row.names=1)

# Import Shared Files
OTUs <- read.otu(shared = "data/hja_streams.shared", cutoff = "0.03") # 97% Similarity

# Import Taxonomy
OTU.tax <- read.tax(taxonomy = "data/hja_streams.0.03.taxonomy", format = "rdp")

# Import Env
env.total <- read.csv("data/hja_env.csv", header=T)

# Check to see that the OTU table rows are same order as design and then rename OTU table rows 
sites <- as.data.frame(str_split(rownames(design.total), "_", simplify = T))
colnames(sites) <- c("ws", "site", "habitat")
oturows <- rownames(OTUs) %>% str_sub(7)
if(all.equal.character(paste0(sites$ws, sites$site, sites$habitat), oturows)){
  rownames(OTUs) <- rownames(design.total)
}
rownames(OTUs)
```

Next, we will clean up the data and perform some transformations. 
```{r cleanup, cache=TRUE}
# Sequencing Coverage
coverage <- rowSums(OTUs)

# Remove Low Coverage Samples
cutoff <- 10000
lows <- which(coverage < cutoff)
OTUs <- OTUs[-which(coverage < cutoff), ]
design <- design.total[-which(coverage < cutoff), ]
env <- env.total[-which(coverage < cutoff), ]

# Remove OTUs with less than 5 occurances across all sites
OTUs <- OTUs[, which(colSums(OTUs) >= 10)]


den.dists <- as.dist(readRDS(file = "data/dendritic_dists.rda"))
design$upstreamdist <- as.matrix(den.dists)[1,]

# Remove orthogonal vectors
env.mat <- as.matrix(env[10:20])
env.mat["83",9] <- 150 # These were the highest samples, overflow
#env.mat[52,5] <- 150
for(i in 1:nrow(env.mat)){
  if(env.mat[i, 9] < 0){
    env.mat[i, 9] <- 0.0001 # these were below detection of the machine
  }
  if(env.mat[i, 10] < 0){
    env.mat[i, 10] <- 0.0001
  }
}
habitat.dummy <- simba::mad(as.factor(env$habitat))
env.mat <- cbind(habitat.dummy, env.mat)
env.mat <- env.mat[,c("sediment", "elevation", "temperature", "conductivity",
                      "ph", "TN", "TP", "DOC")]

hist(log(env.mat$TP), breaks = 30)
env.mat$TP <- log(env.mat$TP)
hist(log(env.mat$TN), breaks = 30)
env.mat$TN <- log(env.mat$TN)

env.dat <- env.mat
env.mat <- scale(env.mat)

# Rarefy communities
# OTUs <- rrarefy(OTUs, sample = min(rowSums(OTUs)))
# OTUs <- OTUs[,-which(colSums(OTUs) == 0)]
# saveRDS(OTUs, file = "temp/site_by_species_rarefied.rda")
# OTUs <- readRDS("temp/site_by_species_rarefied.rda")

# Transformations and Standardizations
OTUsREL <- decostand(OTUs, method = "total")
OTUs.PA <- decostand(OTUs, method = "pa")
OTUsREL.log <- decostand(OTUs, method = "log")
OTUsREL.hel <- decostand(OTUs, method = "hellinger")

# Read in Distances
# Geo distance Matrix
xy <- cbind(jitter(env$longitude, amount = .0001),
            jitter(env$latitude, amount = .0001))
#geo.dists <- geoXY(env$latitude, env$longitude)
#xy <- project(xy, "+proj=utm +zone=10 +ellps=WGS84")
#dist.mat <- as.matrix(dist(xy, method = "euclidean"))
dist.mat <- earth.dist(xy) * 1000
```
I removed the sites with low coverage, and I removed the OTUs with low abundance across the whole dataset. This left a total of `r nrow(OTUs)` sites and `r ncol(OTUs)` bacterial taxa. 

Here, we will read in the phylogenetic tree, root it, and create the unifract distance matrices. I pruned the phylogenetic tree to match only the taxa remaining in the dataset. Then, I rooted the tree using the midpoint method and computed generalized UniFrac distances with a scaling factor of 0.5, along with unweighted and weighted calculations. 
```{r tree}
# hja.tree <- read.tree("data/hja_streams.tree")
# matched.phylo <- match.phylo.comm(hja.tree, OTUs)
# hja.tree <- matched.phylo$phy
# is.rooted(hja.tree)
# hja.tree.rooted <- midpoint.root(hja.tree)
# is.rooted(hja.tree.rooted)
# saveRDS(object = hja.tree.rooted, file = "temp/hja_tree_rooted.nwk")
hja.tree.rooted <- readRDS(file = "temp/hja_tree_rooted.nwk")

# hja.unifrac <- GUniFrac(otu.tab = OTUs, tree = hja.tree.rooted)$unifracs
# saveRDS(hja.unifrac, file = "temp/hja_unifrac.rda")
hja.unifrac <- readRDS(file = "temp/hja_unifrac.rda")
hja.unifrac.dw <- hja.unifrac[ , ,"d_1"]		  # Weighted UniFrac
hja.unifrac.du <- hja.unifrac[ , ,"d_UW"]		  # Unweighted UniFrac	
hja.unifrac.dv <- hja.unifrac[ , ,"d_VAW"]		# Variance adjusted weighted UniFrac
hja.unifrac.d0 <- hja.unifrac[ , ,"d_0"]    	# GUniFrac with alpha 0  
hja.unifrac.d5 <- hja.unifrac[ , ,"d_0.5"]   	# GUniFrac with alpha 0.5 
```


# Environmental analysis
```{r envplots}
cbind.data.frame(env.dat, design) %>% 
  select(elevation, temperature, conductivity, ph, TN, TP, DOC, upstreamdist) %>% 
  gather(-upstreamdist, key = variable, value = measurement) %>% 
  ggplot(aes(x = upstreamdist, y = measurement)) + 
  facet_wrap(~ variable, scales = "free_y") + 
  geom_point() +
  geom_smooth()
  
```

# Diversity analysis

```{r}
### Richness

# Observed Richness
S.obs <- rowSums((OTUsREL.hel > 0) * 1)

simpsE <- round(apply(OTUsREL, 1, SimpE), 3)
shan <- vegan::diversity(OTUsREL, index = "shannon")
N1 <- exp(shan)
simpsD <- vegan::diversity(OTUsREL, index = "invsimpson")
E1 <- N1/S.obs


```

```{r}
hja.dh <- vegdist(OTUsREL.hel, method = "euclid")
hja.dh.single <- hclust(hja.dh, method = "single")
plot(hja.dh.single,
     labels = rownames(OTUsREL.hel))

hja.dh.ward <- hclust(hja.dh, method = "ward.D2")
plot(hja.dh.ward,
     labels = rownames(OTUsREL.hel))

hja.dh.flex <- agnes(hja.dh, method = "flexible", par.method = 0.625)
hja.dh.flex <- as.hclust(hja.dh.flex)
plot(hja.dh.flex,
     labels = paste(design$watershed, design$habitat, design$order))

cophenetic(hja.dh.flex)
cor(hja.dh, cophenetic(hja.dh.flex))
cor(hja.dh, cophenetic(hja.dh.single))
cor(hja.dh, cophenetic(hja.dh.ward))

```


# 
```{r}
#### PCoA 

# All HJA Catchment
hja.pcoa <- run.pcoa(comm = OTUsREL.hel)

# Sediments Only
sed.pcoa <- run.pcoa(comm = OTUsREL.hel[which(design$habitat == "sediment"),])

# Water Only
water.pcoa <- run.pcoa(comm = OTUsREL.hel[which(design$habitat == "water"),])


# Lookout Creek Watershed Only
lookout.pcoa <- run.pcoa(comm = OTUsREL.hel[which(design$watershed == "LC"),])

# Watershed 01 Only
ws01.pcoa <- run.pcoa(comm = OTUsREL.hel[which(design$watershed == "WS01"),])

# Is habitat or order an important factor in community structure?
hja.permanova <- adonis(hja.pcoa$dist.matrix ~ design$habitat + design$order, permutations = 999)
capture.output(hja.permanova$aov.tab, file = "./tables/hja_permanova.txt")

ord <- ws01.pcoa
ord.pc <- ord$pcoa
scrs <- scores(ord.pc)
xlim <- extendrange(x = .1, r = range(scrs[,1]))
ylim <- extendrange(x = .1, r = range(scrs[,2]))

with(design, levels(habitat))
cols <- c("white", "grey")

plot.new()
plot.window(xlim = xlim, ylim = ylim, asp = 1)
abline(h = 0, lty = "dotted")
abline(v = 0, lty = "dotted")
with(design, points(scrs, col = "black", pch = 21, cex = 2, bg = cols[habitat]))
with(design, legend("topright", legend = levels(habitat), bty = "n",
                      col = "black", pch = 21, pt.bg = cols))
axis(side = 1, lwd.ticks = 2, cex.axis = 1.2)
axis(side = 2, lwd.ticks = 2, cex.axis = 1.2)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1.2)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1.2)
title(xlab = paste("PCoA 1 (",ord$var1,"%)", sep = ""), 
      ylab = paste("PCoA 2 (",ord$var2,"%)", sep = ""), cex.lab = 1.2)
box(lwd = 2)






```

# Appendix: Session Info
```{r}
sessionInfo()
```

