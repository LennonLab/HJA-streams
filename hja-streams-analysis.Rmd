---
title: Bacterial community assembly differs between benthic and planktonic stream
  habitats
author: "Nathan I. Wisnoski and Jay T. Lennon"
date: "2019-01-04"
output: pdf_document
---

# Initial setup 
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  fig.align = "center", 
  fig.width = 6,
  message = FALSE,
  warning = FALSE
)

library("vegan")
library("adespatial")
library("pander")
library("stringr")
library("picante")
library("phytools")
library("GUniFrac")
library("tidyverse")

theme_set(theme_minimal() +
            theme(axis.title = element_text(size = 16),
                  axis.text = element_text(size = 12),
                  legend.position = "top", 
                  strip.text = element_text(size = 12),
                  legend.text = element_text(size = 12),
                  legend.title = element_text(size = 14)))

# used https://www.color-hex.com/color-palette/71977
my.colors <- c("#d5ba94", "#3a4f6a")

# load external functions
source("analysis/mothur_tools.R")
source("analysis/hja_functions.R")
```

First, we load the data. This includes the site-by-species matrix (generated in Mothur, v. 1.41.1), the RDP taxonomy, the environmental data, and the phylogenetic tree (generated with FastTreeMP).
```{r load, echo=FALSE, message=FALSE}
## Import Shared, Design, and Environment Files

# Define Inputs
# Design = general design file for experiment
# shared = OTU table from mothur with sequence similarity clustering
# Taxonomy = Taxonomic information for each OTU

# Import Design
design.total <- read.delim("data/design.txt", header=T, row.names=1)

# Import Shared Files
OTUs <- read.otu(shared = "data/hja_streams.shared", cutoff = "0.03") # 97% Similarity

# Import Taxonomy
OTU.tax <- read.tax(taxonomy = "data/hja_streams.0.03.taxonomy", format = "rdp")

# Import Env
env.total <- read_csv("data/hja_env.csv", 
                      col_types = cols(
                        date = col_date(format = "%d-%b-%y"),
                        habitat = col_factor(levels = c("sediment", "water"), ordered = F)))

# Check to see that the OTU table rows are same order as design and then rename OTU table rows 
sites <- as.data.frame(str_split(rownames(design.total), "_", simplify = T))
colnames(sites) <- c("ws", "site", "habitat")
oturows <- rownames(OTUs) %>% str_sub(7)
if(all.equal.character(paste0(sites$ws, sites$site, sites$habitat), oturows)){
  rownames(OTUs) <- rownames(design.total)
}
```

Next, we will clean up the data. I'll remove any sample that didn't get 10000 reads. Then also cut those samples from the environment and design tables.
```{r cleanup}
# Sequencing Coverage
coverage <- rowSums(OTUs)

# Remove Low Coverage Samples
cutoff <- 10000
lows <- which(coverage < cutoff)
OTUs <- OTUs[-which(coverage < cutoff), ]
design <- design.total[-which(coverage < cutoff), ]
env <- env.total[-which(coverage < cutoff), ]

# Remove OTUs with less than 5 occurances across all sites
OTUs <- OTUs[, which(colSums(OTUs) >= 10)]

OTUs <- OTUs[-which(env$sample == "W1_20_W"),]
design <- design[-which(env$sample == "W1_20_W"),]
env <- env[-which(env$sample == "W1_20_W"),]
```

Here, I'll read in the dendritic distances and add a tiny bit of jitter to the spatial distances so nearby sites aren't identical. Then, I'll calculate the earth distance in meters.
```{r dendritic}
den.dists <- make.dendritic.dists("data/hja_dendritic-dists.csv")
design$upstreamdist <- as.matrix(den.dists)[1,]

# Read in Distances
# Geo distance Matrix
xy <- cbind(jitter(env$longitude, amount = .0001),
            jitter(env$latitude, amount = .0001))
#geo.dists <- geoXY(env$latitude, env$longitude)
#xy <- project(xy, "+proj=utm +zone=10 +ellps=WGS84")
#dist.mat <- as.matrix(dist(xy, method = "euclidean"))
dist.mat <- fossil::earth.dist(xy) * 1000
```

Next, we will see if any of the environmental variables need to be transformed. I'll then rescale the environmental variables.
```{r env_transfom}
# Remove orthogonal vectors and make numbers below detection close to zero
env.subs <- env %>% select(habitat, elevation, 
                           temperature, conductivity, 
                           ph, TN, TP, DOC) %>% 
  mutate(TN = if_else(TN < 0, 0.001, TN),
         TP = if_else(TP < 0, 0.001, TP))

#hist(log(env.subs$TP), breaks = 30)
#hist(log(env.subs$TN), breaks = 30)

env.subs <- env.subs %>% mutate(TN = log(TN), TP = log(TP))

# rescale variables
env.subs <- env.subs %>% mutate_if(is_double, scale_vec)
```

Now, I'll perform some transformations on the abundance data. I'll work with the Hellinger-transformed data for the rest of the analysis.
```{r abund_transform}
# Rarefy communities
# OTUs <- rrarefy(OTUs, sample = min(rowSums(OTUs)))
# OTUs <- OTUs[,-which(colSums(OTUs) == 0)]
# saveRDS(OTUs, file = "temp/site_by_species_rarefied.rda")
# OTUs <- readRDS("temp/site_by_species_rarefied.rda")

# Transformations and Standardizations
OTUsREL <- decostand(OTUs, method = "total")
OTUs.PA <- decostand(OTUs, method = "pa")
OTUsREL.log <- decostand(OTUs, method = "log")
OTUsREL.hel <- decostand(OTUs, method = "hellinger")
```
I removed the sites with low coverage, and I removed the OTUs with low abundance across the whole dataset. This left a total of `r nrow(OTUs)` sites and `r ncol(OTUs)` bacterial taxa. 

Here, we will read in the phylogenetic tree, root it, and create the unifract distance matrices. I pruned the phylogenetic tree to match only the taxa remaining in the dataset. Then, I rooted the tree using the midpoint method and computed generalized UniFrac distances with a scaling factor of 0.5, along with unweighted and weighted calculations. 
```{r tree, message=FALSE}
# hja.tree <- read.tree("data/hja_streams.tree")
# matched.phylo <- match.phylo.comm(hja.tree, OTUs)
# hja.tree <- matched.phylo$phy
# is.rooted(hja.tree)
# hja.tree.rooted <- midpoint.root(hja.tree)
# is.rooted(hja.tree.rooted)
# saveRDS(object = hja.tree.rooted, file = "temp/hja_tree_rooted.nwk")
hja.tree.rooted <- readRDS(file = "temp/hja_tree_rooted.nwk")

# hja.unifrac <- GUniFrac(otu.tab = OTUs, tree = hja.tree.rooted)$unifracs
# saveRDS(hja.unifrac, file = "temp/hja_unifrac.rda")
hja.unifrac <- readRDS(file = "temp/hja_unifrac.rda")
hja.unifrac.dw <- as.dist(hja.unifrac[,,"d_1"])		  # Weighted UniFrac
hja.unifrac.du <- as.dist(hja.unifrac[,,"d_UW"])		  # Unweighted UniFrac	
hja.unifrac.dv <- as.dist(hja.unifrac[,,"d_VAW"])		# Variance adjusted weighted UniFrac
hja.unifrac.d0 <- as.dist(hja.unifrac[,,"d_0"])    	# GUniFrac with alpha 0  
hja.unifrac.d5 <- as.dist(hja.unifrac[,,"d_0.5"])   	# GUniFrac with alpha 0.5 
```


# Environmental analysis
Here, I'll just plot the environmental variables from downstream to upstream across the watershed.
```{r envplots, fig.asp=(1/.618)}
env.subs %>% mutate(upstreamdist = design$upstreamdist, watershed = design$watershed) %>% 
  gather(-upstreamdist, -watershed, -habitat, key = variable, value = measurement) %>% 
  ggplot(aes(x = upstreamdist, y = measurement, color = watershed)) + 
  facet_wrap(~ variable,  ncol = 1) + 
  geom_point() +
  geom_smooth() + 
  theme(legend.position = "top") +
  scale_x_continuous(labels = scales::wrap_format(10)) + 
  labs(x = "Upstream distance (m)", 
       y = "Value (z-score)",
       color = "Watershed")
```

# Diversity analysis
```{r fig_alpha}
alpha.tbl <- tibble(
  habitat = str_to_title(design$habitat),
  upstream = design$upstreamdist,
  N0 = rowSums(OTUsREL.hel > 0),
  N1 = exp(diversity(OTUsREL.hel, index = "shannon")),
  N2 = diversity(OTUsREL, index = "invsimpson")
)

alpha.tbl %>% 
  ggplot(aes(x = habitat, y = N1, fill = habitat)) +
  geom_boxplot() +
  labs(x = "", y = expression(paste(alpha, "-Diversity (Species Equivalents)"))) +
  scale_fill_manual(values = (my.colors)) +
  guides(fill = FALSE) +
  scale_y_continuous(limits = c(0, 3500))
```

# Beta diversity: 
### Ordination
```{r run_pcoa, fig.show='hide'}
hja.pcoa <- run.pcoa(comm = OTUsREL.hel, dist.metric = "euclidean", plot = T)
pcoa.ellipse <- ordiellipse(hja.pcoa$pcoa, str_to_title(design$habitat), display = "sites",
            kind = "se", conf = 0.95, label = T)
pcoa.plot <- cbind.data.frame(scores(hja.pcoa$pcoa), group = str_to_title(design$habitat))
df_ell <- calc.ellipse(ord = pcoa.plot, ellipse = pcoa.ellipse)


# Run a PERMANOVA
hja.permanova <- adonis(hja.pcoa$dist.matrix ~ design$habitat * design$order, permutations = 999)
hja.permanova$aov.tab %>% pander::pander()
capture.output(hja.permanova$aov.tab, file = "./tables/hja_permanova.txt")
```

```{r fig_pcoa}
ggplot(data = pcoa.plot, aes(Dim1, Dim2)) +
  geom_point(aes(color = group, shape = group), size = 3, alpha = .8) +
  geom_point(data = subset(pcoa.plot, group == "Sediment"), shape = 1, color = "black", size = 3) +
  geom_point(data = subset(pcoa.plot, group == "Water"), shape = 2, color = "black", size = 3) +
  geom_path(data = df_ell, 
            aes(x = Dim1, y = Dim2, color = group),
            size = 1, alpha = 1, linetype = 2) +
  labs(x = paste0("PCoA1 (", hja.pcoa$var1, "%)"),
    y = paste0("PCoA2 (", hja.pcoa$var2, "%)"),
    color = "Habitat", shape = "Habitat") +
  scale_color_manual(values = my.colors) + 
  coord_fixed()
```

Now, we'll run an RDA. 
```{r dbrda, cache=TRUE}
hja.rda <- rda(OTUsREL.hel ~ ., env.subs)
RsquareAdj(hja.rda)
anova(hja.rda, permutations = how(nperm = 999))
anova(hja.rda, by = "axis", permutations = how(nperm = 999))
```
We see that the RDA is globally significant and the first two canonical axes are also significant. Because the full model was significant, I'll run a model selection procedure.

```{r}
hja.rda.0 <- rda(OTUsREL.hel ~ 1, data = env.subs)
hja.forward <- ordiR2step(hja.rda.0, 
                          scope = formula(hja.rda),
                          direction = "forward",
                          R2scope = TRUE,
                          permutations = how(nperm = 199))
RsquareAdj(hja.forward)
anova(hja.forward, permutations = how(nperm = 999))
anova(hja.forward, by = "axis", permutations = how(nperm = 999))
```
The model selection procedure left us with the model using only habitat, elevation, and TP as predictor variables. Now, we have 3 significant RDA axes with the more parsimonious model. 



### LCBD and SCBD
Now, I'm going calculate the total beta diversity in the samples, and calcluate the local contributions to beta diversity (LCBD) and species contributions to beta diversity (SCBD). LCBD may be highest in more isolated reaches of the stream network
```{r calc_LCBD, cache=TRUE}
otu.beta <- beta.div(OTUs, method = "hellinger", nperm = 9999)
```

```{r fig_LCBD}
otu.beta$beta # max is 1

# which taxa contribute most to beta diversity?
OTU.tax[order(otu.beta$SCBD[otu.beta$SCBD > mean(otu.beta$SCBD)], 
              decreasing = T)[1:10],-c(1,2)] %>% 
  remove_rownames() %>% pander()

row.names(OTUs[which(otu.beta$p.adj <= 0.05),])
design[which(otu.beta$p.adj <= 0.05),]
beta.tbl <- cbind.data.frame(
  design,
  LCBD = otu.beta$LCBD,
  pval = otu.beta$p.adj)
beta.tbl %>% 
  ggplot(aes(x = upstreamdist, y = LCBD, color = watershed, fill = watershed)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", formula = y ~ x + I(x^2)) +
  scale_x_continuous(labels = scales::comma) +
  labs(x = "Upstream distance (m)", color = "Watershed", fill = "Watershed")
  

```
We observed \(BD_{total} = `r round(otu.beta$beta[2], 3)`\) out of 1. 

```{r}


```

\newpage
# Appendix: Session Info
```{r}
sessionInfo()
```

