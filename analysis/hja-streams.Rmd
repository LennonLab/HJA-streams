---
title: 'Analysis for Stream Microbial Metacommunity'
date: '`r format(Sys.time(), '%d %B, %Y')`'
output: pdf_document
---
### Initial Setup
```{r}
rm(list=ls())
setwd("~/GitHub/HJA-streams/")
opar <- par()
```

### Import Source Files and Packages
```{r}
source("./analysis/MothurTools.R")

require("vegan")
require("png")
require("raster")
require("sp")
require("rgdal")

se <- function(x, ...){sd(x, na.rm = TRUE)/sqrt(length(na.omit(x)))}

error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
  if(length(x) != length(y) | length(y) !=length(lower) | length(lower) != length(upper))
    stop("vectors must be same length")
  arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
}

```


### Import Shared, Design, and Environment Files
```{r}
# Define Inputs
# Design = general design file for experiment
# shared = OTU table from mothur with sequence similarity clustering
# Taxonomy = Taxonomic information for each OTU
design <- "./data/design.txt"
shared <- "./data/hja_streams.final.shared"
taxon  <- "./data/hja_streams.final.0.03.taxonomy"
env    <- "./data/hja_env.csv"

# Import Design
design <- read.delim(design, header=T, row.names=1)

# Import Shared Files
OTUs <- read.otu(shared = shared, cutoff = "0.03")         # 97% Similarity

# Import Taxonomy
OTU.tax <- read.tax(taxonomy = taxon, format = "rdp")

# Import Env
env.total <- read.csv(env, header=T)

```

### Data Transformations
```{r}
# Remove OTUs with less than two occurances across all sites
OTUs <- OTUs[, which(colSums(OTUs) >= 2)]

# Sequencing an Good's Coverage
# Sequencing Coverage
coverage <- rowSums(OTUs)

# Good's Coverage
goods <- function(x = ""){
  1 - (sum(x == 1) / rowSums(x))
}
goods.c <- goods(OTUs)

# Remove Low Coverage Samples
lows <- which(coverage < 7000)
lows
OTUs <- OTUs[-which(coverage < 7000), ]
design <- design[-which(coverage < 7000), ]
env <- env.total[-which(coverage < 7000), ]

# Remove orthogonal vectors
env <- env[c(1:11, 13, 16, 18, 19)]
env.mat <- as.matrix(env[10:15])
for(i in 1:nrow(env.mat)){
  if(env.mat[i, 5] < 0){
    env.mat[i, 5] <- 0
  }
}

# Distance Matrix
xy <- cbind(env$longitude, env$latitude)
xy <- project(xy, "+proj=utm +zone=10 +ellps=WGS84")
dist.mat <- as.matrix(dist(xy, method = "euclidean"))

# Make Relative Abundence Matrices
OTUsREL <- OTUs
for(i in 1:dim(OTUs)[1]){
  OTUsREL[i,]<- OTUs[i,]/sum(OTUs[i,])
}

# Log Transform Relative Abundances
OTUsREL.log <- decostand(OTUs, method="log")

OTUs.PA <- (OTUs > 0) * 1

```

### Calculate Alpha Diversity
```{r}
# Observed Richness
S.obs <- rowSums((OTUs > 0) * 1)

# Simpson's Evenness
SimpE <- function(x = ""){
  x <- as.data.frame(x)
  D <- diversity(x, "inv")
  S <- sum((x > 0) * 1) 
  E <- (D)/S 
  return(E)
}
simpsE <- round(apply(OTUs, 1, SimpE), 3)

# Shannon's Diversity
H <- function(x = ""){
  x <- x[x>0]
  H = 0
  for (n_i in x){
    p = n_i / sum(x)
    H = H - p*log(p) 
  }
  return(H)
}

shan <- round(apply(OTUs, 1, H), 2)
shan2 <- diversity(OTUs, index = "shannon")

# Rarefaction
hja.S <- rowSums((OTUs > 0) * 1)
min.N <- min(rowSums(OTUs))
#S.rarefy <- rarefy(x = OTUs, sample = min.N, se = TRUE)
#rarecurve(x = OTUs, step = 20, col = "blue", cex = 0.6, las = 1)
#rared <- t(S.rarefy)

alpha.div <- cbind(design, S.obs, simpsE, shan)
```


#### Alpha Diversity Across Habitats
```{r}
# Seperate data based on water and sediment samples
water <- alpha.div[alpha.div$habitat == "water",]
sed <- alpha.div[alpha.div$habitat == "sediment", ]

lc   <- alpha.div[alpha.div$watershed == "LC",]
ws01 <- alpha.div[alpha.div$watershed == "WS01",]

t.test(alpha.div$S.obs ~ alpha.div$habitat)

cor.test(alpha.div$S.obs, alpha.div$simpsE)
```

### Ordination

#### PCoA 
```{r}
# All HJA Catchment
hja.db <- vegdist(OTUsREL, method = "bray", upper = TRUE, diag = TRUE)
hja.pcoa <- cmdscale(hja.db, eig=TRUE, k=3)
var1 <- round(hja.pcoa$eig[1] / sum(hja.pcoa$eig),3) * 100
var2 <- round(hja.pcoa$eig[2] / sum(hja.pcoa$eig),3) * 100
var3 <- round(hja.pcoa$eig[3] / sum(hja.pcoa$eig),3) * 100

# Sediments Only
sediment <- OTUsREL.log[which(design$habitat == "sediment"),]
sediment.db <- vegdist(sediment, method = "bray", diag = T)
sediment.pcoa <- cmdscale(sediment.db, eig=TRUE, k=3)
sed.design <- design[which(design$habitat == "sediment"),]
s.var1 <- round(sediment.pcoa$eig[1] / sum(sediment.pcoa$eig),3) * 100
s.var2 <- round(sediment.pcoa$eig[2] / sum(sediment.pcoa$eig),3) * 100
s.var3 <- round(sediment.pcoa$eig[3] / sum(sediment.pcoa$eig),3) * 100

# Water Only
water <- OTUsREL.log[which(design$habitat == "water"),]
water.db <- vegdist(water, method = "bray", diag = T)
water.pcoa <- cmdscale(water.db, eig=TRUE, k=3)
water.design <- design[which(design$habitat == "water"),]
w.var1 <- round(water.pcoa$eig[1] / sum(water.pcoa$eig),3) * 100
w.var2 <- round(water.pcoa$eig[2] / sum(water.pcoa$eig),3) * 100
w.var3 <- round(water.pcoa$eig[3] / sum(water.pcoa$eig),3) * 100

# Lookout Creek Watershed Only
lc <- OTUsREL[which(design$watershed == "LC"),]
lc.db <- vegdist(lc, method = "bray", diag = T)
lc.pcoa <- cmdscale(lc.db, eig=TRUE, k=3)
lc.design <- design[which(design$watershed == "LC"),]
lc.var1 <- round(lc.pcoa$eig[1] / sum(lc.pcoa$eig),3) * 100
lc.var2 <- round(lc.pcoa$eig[2] / sum(lc.pcoa$eig),3) * 100
lc.var3 <- round(lc.pcoa$eig[3] / sum(lc.pcoa$eig),3) * 100

# Watershed 01 Only
w1 <- OTUsREL[which(design$watershed == "WS01"),]
w1.db <- vegdist(w1, method = "bray", diag = T)
w1.pcoa <- cmdscale(w1.db, eig=TRUE, k=3)
w1.design <- design[which(design$watershed == "WS01"),]
w1.var1 <- round(w1.pcoa$eig[1] / sum(w1.pcoa$eig),3) * 100
w1.var2 <- round(w1.pcoa$eig[2] / sum(w1.pcoa$eig),3) * 100
w1.var3 <- round(w1.pcoa$eig[3] / sum(w1.pcoa$eig),3) * 100
```

#### Figure 1: Sediments & Water Communities PCoA
```{r}
png(filename = "./figures/Figure1.png",
    width = 1200, height = 1200, res = 96*2)

par(mar = c(5, 5, 3, 2) + 0.1)
plot(hja.pcoa$points[ ,1], hja.pcoa$points[ ,2], ylim = c(-0.5, 0.4), xlim = c(-.35, .35),
     xlab = paste("PCoA 1 (", var1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", var2, "%)", sep = ""), 
     pch = 19, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = F,
     main="H.J. Andrews Catchment")
axis(side = 1, labels = T, at = c(-0.3,-.15,0,.15,.3), lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 3, labels = F, at = c(-0.3,-.15,0,.15,.3), lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
points(hja.pcoa$points[which(design$habitat == "sediment"),1], 
       hja.pcoa$points[which(design$habitat == "sediment"),2],
       pch=19, cex=2, bg="wheat", col="wheat")
points(hja.pcoa$points[which(design$habitat == "water"),1], 
       hja.pcoa$points[which(design$habitat == "water"),2],
       pch=17, cex=2, bg="skyblue", col="skyblue")
# text(hja.pcoa$points[ ,1], hja.pcoa$points[ ,2],
#      cex = 0.5, labels = row.names(hja.pcoa$points))
legend("topleft", c("Sediment", "Water"), col = c("wheat", "skyblue"),
         pt.bg = c("wheat", "skyblue"), pch = c(19,17), cex = 1.5, bty = "n")

dev.off()
graphics.off()
```

#### Figure 2: Surface Water vs. Sediment Communities
```{r}

png(filename = "./figures/Figure2.png",
    width = 2400, height = 1200, res = 96*2)
par(mfrow = c(1,2))

# Sediments Only PCoA
par(mar = c(5, 5, 3, 2) + 0.1)
plot(sediment.pcoa$points[ ,1], sediment.pcoa$points[ ,2], ylim = c(-0.4, 0.4), xlim = c(-.4,.4),
     xlab = paste("PCoA 1 (", s.var1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", s.var2, "%)", sep = ""), 
     pch = 19, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = F,
     main="Sediments")
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
points(sediment.pcoa$points[which(sed.design$watershed == "LC"),1], 
       sediment.pcoa$points[which(sed.design$watershed == "LC"),2],
       pch=19, cex=2, bg="slategray2", col="slategray2")
points(sediment.pcoa$points[which(sed.design$watershed == "WS01"),1], 
       sediment.pcoa$points[which(sed.design$watershed == "WS01"),2],
       pch=17, cex=2, bg="yellowgreen", col="yellowgreen")
# text(sediment.pcoa$points[ ,1], sediment.pcoa$points[ ,2],
#      cex=0.5, labels = row.names(sediment.pcoa$points))
legend("topleft", c("Lookout Creek", "Watershed 01"), col = c("slategray2", "yellowgreen"),
       pt.bg = c("slategray2", "yellowgreen"), pch = c(19,17), cex = 1.5, bty = "n")

# Water Only PCoA
par(mar = c(5, 5, 3, 2) + 0.1)
plot(water.pcoa$points[ ,1], water.pcoa$points[ ,2], ylim = c(-0.4, 0.4), xlim = c(-.5,.4),
     xlab = paste("PCoA 1 (", w.var1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", w.var2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = F,
     main="Water")
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
points(water.pcoa$points[which(water.design$watershed == "LC"),1], 
       water.pcoa$points[which(water.design$watershed == "LC"),2],
       pch=19, cex=2, bg="slategray2", col="slategray2")
points(water.pcoa$points[which(water.design$watershed == "WS01"),1], 
       water.pcoa$points[which(water.design$watershed == "WS01"),2],
       pch=17, cex=2, bg="yellowgreen", col="yellowgreen")
# text(water.pcoa$points[ ,1], water.pcoa$points[ ,2],
#      cex=0.5, labels = row.names(water.pcoa$points))

dev.off()
graphics.off()

```

### Calculate Bray-Curtis across stream orders
```{r}
strahler.bray <- 1 - as.matrix(vegdist(OTUsREL.log, method = "bray"))
order.1.bray <- strahler.bray[which(design$order==1),which(design$order==1)]
order.2.bray <- strahler.bray[which(design$order==2),which(design$order==2)]
order.3.bray <- strahler.bray[which(design$order==3),which(design$order==3)]
order.4.bray <- strahler.bray[which(design$order==4),which(design$order==4)]
order.5.bray <- strahler.bray[which(design$order==5),which(design$order==5)]

order.1.bray.mean <- mean(as.vector(round(apply(order.1.bray, 1, mean), 3)))
order.2.bray.mean <- mean(as.vector(round(apply(order.2.bray, 1, mean), 3)))
order.3.bray.mean <- mean(as.vector(round(apply(order.3.bray, 1, mean), 3)))
order.4.bray.mean <- mean(as.vector(round(apply(order.4.bray, 1, mean), 3)))
order.5.bray.mean <- mean(as.vector(round(apply(order.5.bray, 1, mean), 3)))

order.1.bray.se <- mean(as.vector(round(apply(order.1.bray, 1, se), 3)))
order.2.bray.se <- mean(as.vector(round(apply(order.2.bray, 1, se), 3)))
order.3.bray.se <- mean(as.vector(round(apply(order.3.bray, 1, se), 3)))
order.4.bray.se <- mean(as.vector(round(apply(order.4.bray, 1, se), 3)))
order.5.bray.se <- mean(as.vector(round(apply(order.5.bray, 1, se), 3)))

orders.bray <- as.data.frame(cbind(c(rep(1, length(order.1.bray.mean)),
        rep(2, length(order.2.bray.mean)),
        rep(3, length(order.3.bray.mean)),
        rep(4, length(order.4.bray.mean)),
        rep(5, length(order.5.bray.mean))),
      c(order.1.bray.mean, order.2.bray.mean, order.3.bray.mean,
        order.4.bray.mean, order.5.bray.mean),
      c(order.1.bray.se, order.2.bray.se, order.3.bray.se,
        order.4.bray.se, order.5.bray.se)))
colnames(orders.bray) <- c("order", "mean", "se")
model.orders <- lm(orders.bray$mean ~ orders.bray$order)
modsum <- summary(model.orders)
```

### Figure 3: Bray-Curtis Similarity increases with increasing stream order
```{r}
png(filename = "./figures/Figure3.png",
    width = 1200, height = 1200, res = 96*2)
par(mar = c(5, 5, 2, 2) + 0.1)
plot(orders.bray$mean ~ orders.bray$order, xaxt = "n", yaxt = "n",
     xlab = "Stream Order", ylab = "Mean Bray-Curtis Similarity", ylim = c(0.2, 0.7),
     pch = 19, cex.lab =1.5)
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 3, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 4, labels = F, lwd.ticks = 2, cex.axis = 1.2, las = 1)
box(lwd=2)

error.bar(orders.bray$order, orders.bray$mean, orders.bray$se)

abline(model.orders)
r2 <- modsum$adj.r.squared
my.p <- modsum$coefficients[2,4]
rp <- vector('expression',2)
rp[1] <- substitute(expression(italic(R)^2 == MYVALUE),
                    list(MYVALUE = format(r2,dig=3)))[2]
rp[2] <- substitute(expression(italic(p) == MYOTHERVALUE),
                    list(MYOTHERVALUE = format(my.p, digits = 2)))[2]
legend('bottomright', legend = rp, bty = 'n')
dev.off()
graphics.off()
```


### Organismal analysis
```{r}
top.taxa = matrix(nrow = nrow(OTUsREL), ncol = 5)
rownames(top.taxa) <- rownames(OTUsREL)
for(i in 1:nrow(OTUsREL)){
  top.taxa[i,] <- names(sort(tail(sort(OTUsREL[i,]),5), decreasing = T))
}

OTU.tax[OTU.tax$OTU %in% unique(as.vector(top.taxa[,5])),]

OTU.tax[OTU.tax$OTU %in% unique(as.vector(top.taxa[which(design$habitat == "water")])),]
OTU.tax[OTU.tax$OTU %in% unique(as.vector(top.taxa[which(design$habitat == "sediment")])),]

```

#### Figure S1: Surface-water / Sediment differences are robust across scales
```{r}

png(filename = "./figures/FigureS1.png",
    width = 2400, height = 1200, res = 96*2)
par(mfrow = c(1,2))

# Lookout Creek PCoA
par(mar = c(5, 5, 3, 2) + 0.1)
plot(lc.pcoa$points[ ,1], lc.pcoa$points[ ,2], ylim = c(-0.4, 0.35),
     xlab = paste("PCoA 1 (", lc.var1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", lc.var2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = F,
     main="Lookout Creen Watershed")
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
points(lc.pcoa$points[which(lc.design$habitat == "water"),1], 
       lc.pcoa$points[which(lc.design$habitat == "water"),2],
       pch=19, cex=2, bg="skyblue", col="skyblue")
points(lc.pcoa$points[which(lc.design$habitat == "sediment"),1], 
       lc.pcoa$points[which(lc.design$habitat == "sediment"),2],
       pch=19, cex=2, bg="wheat", col="wheat")
text(lc.pcoa$points[ ,1], lc.pcoa$points[ ,2],
     cex=0.5, labels = row.names(lc.pcoa$points))

# WS01 PCoA
par(mar = c(5, 5, 3, 2) + 0.1)
plot(w1.pcoa$points[ ,1], w1.pcoa$points[ ,2], ylim = c(-0.4, 0.35),
     xlab = paste("PCoA 1 (", w1.var1, "%)", sep = ""),
     ylab = paste("PCoA 2 (", w1.var2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = F,
     main="Watershed 01")
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
points(w1.pcoa$points[which(w1.design$habitat == "water"),1], 
       w1.pcoa$points[which(w1.design$habitat == "water"),2],
       pch=19, cex=2, bg="skyblue", col="skyblue")
points(w1.pcoa$points[which(w1.design$habitat == "sediment"),1], 
       w1.pcoa$points[which(w1.design$habitat == "sediment"),2],
       pch=19, cex=2, bg="wheat", col="wheat")
text(w1.pcoa$points[ ,1], w1.pcoa$points[ ,2],
     cex=0.5, labels = row.names(w1.pcoa$points))

dev.off()
graphics.off()
```

### CCA across watersheds and habitats
```{r}
# LC Watershed
lc.cca <- vegan::cca(OTUsREL.log[which(design$watershed == "LC"),] ~ env.mat[which(design$watershed == "LC"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
lc.cca.explainvar1 <- round(lc.cca$CCA$eig[1] /
                           sum(c(lc.cca$CCA$eig, lc.cca$CA$eig)), 3) * 100
lc.cca.explainvar2 <- round(lc.cca$CCA$eig[2] /
                           sum(c(lc.cca$CCA$eig, lc.cca$CA$eig)), 3) * 100

# WS01
w1.cca <- vegan::cca(OTUsREL.log[which(design$watershed == "WS01"),] ~ env.mat[which(design$watershed == "WS01"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
w1.cca.explainvar1 <- round(w1.cca$CCA$eig[1] /
                           sum(c(w1.cca$CCA$eig, w1.cca$CA$eig)), 3) * 100
w1.cca.explainvar2 <- round(w1.cca$CCA$eig[2] /
                           sum(c(w1.cca$CCA$eig, w1.cca$CA$eig)), 3) * 100

# Water Only
water.cca <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),] ~ env.mat[which(design$habitat == "water"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
water.cca.explainvar1 <- round(water.cca$CCA$eig[1] /
                           sum(c(water.cca$CCA$eig, water.cca$CA$eig)), 3) * 100
water.cca.explainvar2 <- round(water.cca$CCA$eig[2] /
                           sum(c(water.cca$CCA$eig, water.cca$CA$eig)), 3) * 100

# Sediments Only
sediment.cca <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),] ~ env.mat[which(design$habitat == "sediment"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
sediment.cca.explainvar1 <- round(sediment.cca$CCA$eig[1] /
                           sum(c(sediment.cca$CCA$eig, sediment.cca$CA$eig)), 3) * 100
sediment.cca.explainvar2 <- round(sediment.cca$CCA$eig[2] /
                           sum(c(sediment.cca$CCA$eig, sediment.cca$CA$eig)), 3) * 100

```

#### Figure S2: Environmental variables explain little variation in structure. Elevation seems important.
```{r}
png(filename = "./figures/FigureS2.png",
    width = 2400, height = 1800, res=96*2)
par(mfrow=c(2,2))

# Lookout Plot
par(mar = c(5, 5, 4, 4) + 0.1)
plot(scores(lc.cca, display = "wa"), xlim = c(-2, 3), ylim = c(-2.5, 2),
     xlab = paste("CCA 1 (", lc.cca.explainvar1, "%)", sep = ""), 
     ylab = paste("CCA 2 (", lc.cca.explainvar2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = FALSE,
     main="Lookout Creek")
axis(side=1, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
axis(side=2, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
abline(h=0, v=0, lty=3)
box(lwd=2)
points(scores(lc.cca, display = "wa"),
       pch=19, cex=2, bg="gray", col="gray")
text(scores(lc.cca, display = "wa"), cex=0.5,
     labels = row.names(scores(lc.cca, display = "wa")))

lc.vectors <- scores(lc.cca, display = "bp")
row.names(lc.vectors) <- c("elev", "temp", "cond", "pH", "TN", "TP")
arrows(0, 0, lc.vectors[, 1] * 2, lc.vectors[, 2]*2,
       lwd = 2, lty = 1, length = 0.2, col = "red")
text(lc.vectors[, 1] * 2, lc.vectors[, 2] * 2, pos=3,
     labels = row.names(lc.vectors), col = "red")

# WS01 Plot
par(mar = c(5, 5, 4, 4) + 0.1)
plot(scores(w1.cca, display = "wa"), xlim = c(-3,3), ylim = c(-3, 2),
     xlab = paste("CCA 1 (", w1.cca.explainvar1, "%)", sep = ""), 
     ylab = paste("CCA 2 (", w1.cca.explainvar2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = FALSE,
     main = "Watershed 1")
axis(side=1, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
axis(side=2, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
abline(h=0, v=0, lty=3)
box(lwd=2)
points(scores(w1.cca, display = "wa"),
       pch=19, cex=2, bg="gray", col="gray")
text(scores(w1.cca, display = "wa"), cex = 0.5,
     labels = row.names(scores(w1.cca, display = "wa")))

w1.vectors <- scores(w1.cca, display = "bp")
row.names(w1.vectors) <- c("elev", "temp", "spC", "cond", "tds", "sal", "pH")
arrows(0, 0, w1.vectors[, 1] * 2, w1.vectors[, 2]*2,
       lwd = 2, lty = 1, length = 0.2, col = "red")
text(w1.vectors[, 1] * 2, w1.vectors[, 2] * 2, pos=3,
     labels = row.names(w1.vectors), col = "red")


#Water PLot
par(mar = c(5, 5, 4, 4) + 0.1)
plot(scores(water.cca, display = "wa"), xlim = c(-2, 3.5), ylim = c(-3, 2),
     xlab = paste("CCA 1 (", water.cca.explainvar1, "%)", sep = ""), 
     ylab = paste("CCA 2 (", water.cca.explainvar2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = FALSE,
     main = "Water")
axis(side=1, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
axis(side=2, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
abline(h=0, v=0, lty=3)
box(lwd=2)
points(scores(water.cca, display = "wa"),
       pch=19, cex=2, bg="gray", col="gray")
text(scores(water.cca, display = "wa"), cex = 0.5,
     labels = row.names(scores(water.cca, display = "wa")))

water.vectors <- scores(water.cca, display = "bp")
row.names(water.vectors) <- c("elev", "temp", "spC", "cond", "tds", "sal", "pH")
arrows(0, 0, water.vectors[, 1] * 2, water.vectors[, 2]*2,
       lwd = 2, lty = 1, length = 0.2, col = "red")
text(water.vectors[, 1] * 2, water.vectors[, 2] * 2, pos=3,
     labels = row.names(water.vectors), col = "red")

# Sed plot

par(mar = c(5, 5, 4, 4) + 0.1)
plot(scores(sediment.cca, display = "wa"), xlim = c(-2, 3), ylim = c(-2, 2),
     xlab = paste("CCA 1 (", sediment.cca.explainvar1, "%)", sep = ""), 
     ylab = paste("CCA 2 (", sediment.cca.explainvar2, "%)", sep = ""), 
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5, cex.axis = 1.2, axes = FALSE,
     main = "Sediment")
axis(side=1, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
axis(side=2, labels=T, lwd.ticks=2, cex.axis=1.2, las=1)
abline(h=0, v=0, lty=3)
box(lwd=2)
points(scores(sediment.cca, display = "wa"),
       pch=19, cex=2, bg="gray", col="gray")
text(scores(sediment.cca, display = "wa"), cex = 0.5,
     labels = row.names(scores(sediment.cca, display = "wa")))

sediment.vectors <- scores(sediment.cca, display = "bp")
row.names(sediment.vectors) <- c("elev", "temp", "spC", "cond", "tds", "sal", "pH")
arrows(0, 0, sediment.vectors[, 1] * 2, sediment.vectors[, 2]*2,
       lwd = 2, lty = 1, length = 0.2, col = "red")
text(sediment.vectors[, 1] * 2, sediment.vectors[, 2] * 2, pos=3,
     labels = row.names(sediment.vectors), col = "red")

dev.off()
graphics.off()
```

### Distance Decay
```{r, eval=FALSE}
require("simba")

# Water Distance Decay
water.lat <- as.numeric(env$latitude[which(design$habitat == "water")])
water.lon <- as.numeric(env$longitude[which(design$habitat == "water")])

water.struc.dist <- 1 - vegdist(OTUs.REL.log[which(design$habitat == "water"),])
water.coord.dist <- dist(as.matrix(water.lat, water.lon))
water.env.dist <- 1 - vegdist(env[which(design$habitat == "water"), 10:16])

water.struc.dist.ls <- liste(water.struc.dist, entry = "struc")
water.env.dist.ls <- liste(water.env.dist, entry = "env")
water.coord.dist.ls <- liste(water.coord.dist, entry = "dist")

water.distances <- data.frame(water.coord.dist.ls, water.env.dist.ls[,3], water.struc.dist.ls[,3])
names(water.distances)[4:5] <- c("env", "struc")

plot(water.distances$dist, water.distances$struc, xlab="Geographic Distance", 
     ylab = "Bray-Curtis Similarity", main = "Water Distance-Decay")
water.lm <- abline(lm(water.distances$struc ~ water.distances$dist))


# Sediment Distance Decay
sed.lat <- as.numeric(env$latitude[which(design$habitat == "sediment")])
sed.lon <- as.numeric(env$longitude[which(design$habitat == "sediment")])

sed.struc.dist <- 1 - vegdist(OTUsREL.log[which(design$habitat == "sediment"),])
sed.coord.dist <- dist(as.matrix(sed.lat, sed.lon))
sed.env.dist <- 1 - vegdist(env[which(design$habitat == "sediment"), 10:16])

sed.struc.dist.ls <- liste(sed.struc.dist, entry = "struc")
sed.env.dist.ls <- liste(sed.env.dist, entry = "env")
sed.coord.dist.ls <- liste(sed.coord.dist, entry = "dist")

sed.distances <- data.frame(sed.coord.dist.ls, sed.env.dist.ls[,3], sed.struc.dist.ls[,3])
names(sed.distances)[4:5] <- c("env", "struc")

plot(sed.distances$dist, sed.distances$struc, xlab="Geographic Distance", 
     ylab = "Bray-Curtis Similarity", main = "Sediment Distance-Decay")
sed.lm <- abline(lm(sed.distances$struc ~ sed.distances$dist))

dev.off()
graphics.off()

diffslope(sed.distances$dist, sed.distances$struc, water.distances$dist, water.distances$struc)
```

### Figure S3: Bray-Curtis Similarity by Elevation
```{r}
hja.bray <- 1 - as.matrix(vegdist(OTUsREL.log, method = "bray"))
hja.bray.mean <- round(apply(hja.bray, 1, mean), 3)
hja.bray.se <- round(apply(hja.bray, 1, se), 3)
hja.sim <- cbind(design, hja.bray.mean, hja.bray.se)
model.hja <- lm(hja.sim$hja.bray.mean ~ hja.sim$elev * hja.sim$habitat)
summary(model.hja)
plot(hja.sim$hja.bray.mean ~ hja.sim$elev, main = "HJA Catchment",
     ylab = "Bray-Curtis Similarity", xlab = "Elevation")
abline(model.hja)

png(filename = "./figures/FigureS3.png", 
    width = 1200, height = 1200, res = 96*2)
par(mfrow = c(2, 1), mar = c(5, 5, 2, 3) + 0.1)
water.bray <- 1 - as.matrix(vegdist(OTUsREL.log[which(design$habitat=="water"),], method = "bray"))
water.bray.mean <- round(apply(water.bray, 1, mean), 3)
water.bray.se <- round(apply(water.bray, 1, se), 3)
water.sim <- cbind(water.design, water.bray.mean, water.bray.se)
model.water <- lm(water.sim$water.bray.mean ~ water.sim$elev)
summary(model.water)
plot(water.sim$water.bray.mean ~ water.sim$elev, xlab="",
     ylab = "", main="Bray-Curtis Similarity")
mtext("Surface Water", side = 2, line = 3, cex = 1.5)
mtext("Bray-Curtis Similarity", side=3, line=3, cex=1.5)
abline(model.water)

sed.bray <- 1 - as.matrix(vegdist(OTUsREL.log[which(design$habitat=="sediment"),], method = "bray"))
sed.bray.mean <- round(apply(sed.bray, 1, mean), 3)
sed.bray.se <- round(apply(sed.bray, 1, se), 3)
sed.sim <- cbind(sed.design, sed.bray.mean, sed.bray.se)
model.sed <- lm(sed.sim$sed.bray.mean ~ sed.sim$elev)
summary(model.sed)
plot(sed.sim$sed.bray.mean ~ sed.sim$elev, xlab="",
     ylab = "")
abline(model.sed)
mtext("Sediments", side = 2, line = 3, cex = 1.5)
mtext("Elevation (m)", side = 1, line = 3, cex = 1.5)

dev.off()
graphics.off()

```


### GIS and Imagery
```{r}
DEM <- raster("~/GitHub/HJA-streams/imagery/bare_earth_DEM_1m/gi01001.e00")
DEM
image(DEM, col=terrain.colors(1000))
streams <- readOGR(dsn = "./imagery/stream_network_2008/", layer = "lidar_stream")
streams@data
plot(streams, add = TRUE)
summary(streams)
```

### Variance Partitioning

#### Var Part - HJA Catchment
```{r}
dist.pcnm <- pcnm(dist(xy))
ordisurf(xy, scores(dist.pcnm, choi=1), bubble = 4, main = "PCNM 1")
ordisurf(xy, scores(dist.pcnm, choi=2), bubble = 4, main = "PCNM 2")
ordisurf(xy, scores(dist.pcnm, choi=3), bubble = 4, main = "PCNM 3")
ordisplom(dist.pcnm, choices = 1:4)
rs <- rowSums(OTUsREL.log) / sum(OTUsREL.log)
pcnmw <- pcnm(dist(xy), w = rs)

spatial.var <- vegan::cca(OTUsREL.log ~ scores(pcnmw))
env.var <- hja.cca
env.spat.var <- vegan::cca(OTUsREL.log ~ scores(pcnmw) +
                             Condition(env.mat[,c(1:4,6)]))
spat.env.var <- vegan::cca(OTUsREL.log ~ env.mat[,c(1:4,6)] +
                             Condition(scores(pcnmw)))

sum(env.var$CCA$eig)
sum(spatial.var$CCA$eig)
sum(env.spat.var$CCA$eig)
sum(spat.env.var$CCA$eig)

hja.ca <- vegan::cca(OTUsREL.log)
sum(hja.cor$CA$eig)

var.part.1 <- sum(env.var$CCA$eig) / sum(hja.ca$CA$eig)
var.part.2 <- sum(spatial.var$CCA$eig) / sum(hja.ca$CA$eig)
var.part.3 <- sum(spat.env.var$CCA$eig) / sum(hja.ca$CA$eig)
var.part.4 <- sum(env.spat.var$CCA$eig) / sum(hja.ca$CA$eig)
```

#### Var Part - Surface Water
```{r}
env.mat <- env.mat[,c(1:4,6)]
water.dist.pcnm <- pcnm(dist(xy[which(design$habitat == "water"),]))
water.rs <- rowSums(OTUsREL.log[which(design$habitat == "water"),]) / 
  sum(OTUsREL.log[which(design$habitat == "water"),])
water.pcnmw <- pcnm(dist(xy[which(design$habitat == "water"),]), w = water.rs)

water.spatial.var <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),] ~ scores(water.pcnmw))
water.env.var <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),] ~ env.mat[which(design$habitat == "water"),])
water.env.spat.var <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),] ~
      scores(water.pcnmw) + Condition(env.mat[which(design$habitat == "water"),]))
water.spat.env.var <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),] ~ 
      env.mat[which(design$habitat == "water"),] + Condition(scores(water.pcnmw)))

sum(water.env.var$CCA$eig)
sum(water.spatial.var$CCA$eig)
sum(water.env.spat.var$CCA$eig)
sum(water.spat.env.var$CCA$eig)

water.ca <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),])
sum(water.ca$CA$eig)

water.var.part.1 <- sum(water.env.var$CCA$eig) / sum(water.ca$CA$eig)
water.var.part.2 <- sum(water.spatial.var$CCA$eig) / sum(water.ca$CA$eig)
water.var.part.3 <- sum(water.spat.env.var$CCA$eig) / sum(water.ca$CA$eig)
water.var.part.4 <- sum(water.env.spat.var$CCA$eig) / sum(water.ca$CA$eig)
```

#### Var Part - Sediments Only
```{r}
sediment.dist.pcnm <- pcnm(dist(xy[which(design$habitat == "sediment"),]))
sediment.rs <- rowSums(OTUsREL.log[which(design$habitat == "sediment"),]) / 
  sum(OTUsREL.log[which(design$habitat == "sediment"),])
sediment.pcnmw <- pcnm(dist(xy[which(design$habitat == "sediment"),]), w = sediment.rs)

sediment.spatial.var <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),] ~ scores(sediment.pcnmw))
sediment.env.var <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),] ~ env.mat[which(design$habitat == "sediment"),])
sediment.env.spat.var <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),] ~
      scores(sediment.pcnmw) + Condition(env.mat[which(design$habitat == "sediment"),]))
sediment.spat.env.var <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),] ~ 
      env.mat[which(design$habitat == "sediment"),] + Condition(scores(sediment.pcnmw)))

sum(sediment.env.var$CCA$eig)
sum(sediment.spatial.var$CCA$eig)
sum(sediment.env.spat.var$CCA$eig)
sum(sediment.spat.env.var$CCA$eig)

sediment.ca <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),])
sum(sediment.ca$CA$eig)

sediment.var.part.1 <- sum(sediment.env.var$CCA$eig) / sum(sediment.ca$CA$eig)
sediment.var.part.2 <- sum(sediment.spatial.var$CCA$eig) / sum(sediment.ca$CA$eig)
sediment.var.part.3 <- sum(sediment.spat.env.var$CCA$eig) / sum(sediment.ca$CA$eig)
sediment.var.part.4 <- sum(sediment.env.spat.var$CCA$eig) / sum(sediment.ca$CA$eig)
```

```{r}
habitat <- (env[,8] == "sediment") * 1
env.dummy <- as.matrix(cbind(habitat, env[,c(10, 11, 12, 13, 15)]))

d.spatial.var <- spatial.var
d.env.var <- vegan::cca(OTUsREL.log ~ env.dummy)
d.env.spat.var <- vegan::cca(OTUsREL.log ~ scores(pcnmw) +
                             Condition(env.dummy))
d.spat.env.var <- vegan::cca(OTUsREL.log ~ env.dummy +
                             Condition(scores(pcnmw)))

sum(d.env.var$CCA$eig)
sum(d.spatial.var$CCA$eig)
sum(d.env.spat.var$CCA$eig)
sum(d.spat.env.var$CCA$eig)

d.var.part.1 <- sum(d.env.var$CCA$eig) / sum(hja.ca$CA$eig)
d.var.part.2 <- sum(d.spatial.var$CCA$eig) / sum(hja.ca$CA$eig)
d.var.part.3 <- sum(d.spat.env.var$CCA$eig) / sum(hja.ca$CA$eig)
d.var.part.4 <- sum(d.env.spat.var$CCA$eig) / sum(hja.ca$CA$eig)
```


### Calculate Dendritic Distances
```{r}
require('igraph')
adj.mat <- as.matrix(read.csv("./data/undirected-matrix.csv", header=T))
row.names(adj.mat) <- adj.mat[,1]
adj.mat <- adj.mat[,-1]
adj.mat <- (adj.mat == 1) * 1

stream.network <- graph_from_adjacency_matrix(adjmatrix = adj.mat)
plot.igraph(stream.network)

# Create Dist Matrix
euc.dist.mat <- as.matrix(dist(as.matrix(env.total$latitude, env.total$longitude)))
rownames(euc.dist.mat) <- env.total$sample
colnames(euc.dist.mat) <- env.total$sample

# Function to find paths along the network.
dend.dist <- function(graph = "", dist.mat = ""){

  dend.dist.mat <- matrix(data = NA, nrow = length(env.total$sample), 
                          ncol = length(env.total$sample))
  rownames(dend.dist.mat) <- env.total$sample
  colnames(dend.dist.mat) <- env.total$sample
  
  for(row in rownames(dend.dist.mat)){
    for(col in colnames(dend.dist.mat)){
      path.dist <- 0
      path <- shortest_paths(graph = graph, from = row, to = col)$vpath[[1]]
      
      if(length(path) > 1){
        for(i in 1:(length(path) - 1)){
          path.dist <- path.dist + dist.mat[path[[i]]$name, path[[i+1]]$name]
        }
      }
      
      dend.dist.mat[row,col] <- path.dist
    }
  }
  
  return(dend.dist.mat)
}

dend.dist.mat <- dend.dist(graph = stream.network, dist.mat = euc.dist.mat)
```

```{r}
# LC Watershed
hja.pa.cca <- vegan::cca(OTUs.PA[c(1:50,53:56),] ~ env.mat[c(1:50,53:56),]) 



# WS01
w1.cca <- vegan::cca(OTUsREL.log[which(design$watershed == "WS01"),] ~ env.mat[which(design$watershed == "WS01"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
w1.cca.explainvar1 <- round(w1.cca$CCA$eig[1] /
                           sum(c(w1.cca$CCA$eig, w1.cca$CA$eig)), 3) * 100
w1.cca.explainvar2 <- round(w1.cca$CCA$eig[2] /
                           sum(c(w1.cca$CCA$eig, w1.cca$CA$eig)), 3) * 100

# Water Only
water.cca <- vegan::cca(OTUsREL.log[which(design$habitat == "water"),] ~ env.mat[which(design$habitat == "water"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
water.cca.explainvar1 <- round(water.cca$CCA$eig[1] /
                           sum(c(water.cca$CCA$eig, water.cca$CA$eig)), 3) * 100
water.cca.explainvar2 <- round(water.cca$CCA$eig[2] /
                           sum(c(water.cca$CCA$eig, water.cca$CA$eig)), 3) * 100

# Sediments Only
sediment.cca <- vegan::cca(OTUsREL.log[which(design$habitat == "sediment"),] ~ env.mat[which(design$habitat == "sediment"),]) 
#anova(hja.cca, by = "axis")
#cca.fit <- envfit(hja.cca, env.mat, perm = 999)
sediment.cca.explainvar1 <- round(sediment.cca$CCA$eig[1] /
                           sum(c(sediment.cca$CCA$eig, sediment.cca$CA$eig)), 3) * 100
sediment.cca.explainvar2 <- round(sediment.cca$CCA$eig[2] /
                           sum(c(sediment.cca$CCA$eig, sediment.cca$CA$eig)), 3) * 100


```
